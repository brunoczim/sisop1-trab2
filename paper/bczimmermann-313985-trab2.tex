\documentclass[a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[portuguese]{babel}
\usepackage{hyphenat}

\usepackage{geometry}
 \geometry{
 a4paper,
 left=20mm,
 right=20mm,
 top=30mm,
 bottom=20mm,
 }

\usepackage{fancyhdr}
\pagestyle{fancy}
\rhead{Bruno Corrêa Zimmermann -- 313985}
\title{Paginação de Memória, TLB, e Localidade -- Estudo de Caso}
\author{Bruno Corrêa Zimmermann}
\date{20 de Abril de 2022}
\setlength{\headheight}{13pt}

\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{upquote}
\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage{tgcursor}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{biblatex}
\usepackage{csquotes}
\addbibresource{trab2.bib}
\definecolor{LightGray}{gray}{0.9}
\renewcommand{\baselinestretch}{1.5}
\newenvironment{code}[1]{
\VerbatimEnvironment
\begin{minted}[frame=single,baselinestretch=1,fontsize=\small]{#1}}{
\end{minted}
}

\begin{document}

%\fontsize{12}{12}
%\selectfont

\maketitle

NOTA: os códigos se encontram no repositório
https://github.com/brunoczim/sisop1-trab2

\section{Introdução}

Memória virtual é um mecanismo de abstração da memória física que dá a impressão
a um processo de que o espaço de memória onde ele está pertence todo a ele. Uma
forma de implementar esse mecanismo, usada em processadores x86-64, em sistemas
como Linux, é paginação de memória. Nesse sistema, a memória é dividida em
páginas de tamanho fixo, e, no caso de Linux x86-64, o tamanho é 4KiB.

Nesse esquema, há páginas virtuais e páginas físicas. Páginas virtuais são
mapeadas para páginas físicas, mas processos enxergam apenas as páginas
virtuais. Para realizar a tradução entre endereços, é necessário manter tabelas
de páginas. As páginas virtuais podem não estar mapeadas ainda, e nesse caso,
ao tentar acessá-las, o processador gera um sinal chamado
``\textit{Page Fault}'', e então o sistema operacional mapeia a página virtual
para uma página física.

É possível que uma página seja armazenada em disco. Quando um processo tenta
acessar um endereço virtual, busca-se na tabela de páginas a entrada da página
virtual do endereço. Se não está mapeada (\textit{bit} de validade valendo $0$),
busca-se do disco a página e define-se o \textit{bit} de validade para $1$. Em
ambos os casos, ao final, obtém-se o número da página física, e dentro dela, o
enedereço físico é acessado.

Na tabela de páginas, há alguns \textit{bits} de controle para cada entrada.
O \textit{bit} mencionado acima (\textit{bit} de validade) indica se a entrada
na tabela é válida, ou seja, se há um mapeamento válido para a página virtual
associada à entrada. Há ainda o \textit{bit} ``\textit{dirty}'', que indica se a
página física associada àquela entrada na tabela está incosistente com o disco,
e no caso de substituição LRU (\textit{Least Recently Used}), um bit de
referência, indicando se essa entrada foi usada recentemente.

A tabela de páginas é finita, e portanto, quando uma nova página precisa ser
carregada, é possível que outra precise ser descarregada. Existem várias formas
de definir quais páginas serão descarregadas, e o LRU é um algoritmo que resolve
esse problema, substituindo as páginas que foram usadas pela última vez há mais
tempo. Outro algoritmo é o FIFO (\textit{First-in, First-out}), que substitui a
página carregada há mais tempo.

Além da tabela de páginas, existe um \textit{cache} de páginas, chamado TLB
(\textit{Translation-Lookaside Buffer}). O TLB se assemelha a tabela de
páginas convencional, mas é implementado em \textit{hardware}, então, se uma
página está no TLB, faz-se apenas um acesso à memória, em comparação aos
dois acesso pela tabela de página tradicional. Como é um \textit{cache}, ele não
armazena a estrutura toda das tabelas de páginas, mas apenas páginas
específicas, e portanto a TLB também guarda uma \textit{tag} para identificar a
página guardada em uma entrada.

Portanto, para aproveitar a performance do TLB, ou até mesmo da tabela de
páginas convencional, é importante que os programas busquem ter boa localidade.
Por exemplo, sequências de endereços que ``pulam'' páginas podem acabar fazendo
mau uso da TLB. Neste artigo, vamos estudar os efeitos de usar-se diferentes
estruturas de dados, com diferentes algoritmos, e com diferentes localidades.

\section{Localidade e Programas Estudados}

Para explorar efeitos de localidade sobre a TLB, foram experimentadas três
estruturas de dados: \textit{arrays}, árvores binárias, e listas simplesmente
encadeadas. No entanto, para \textit{arrays}, foram usados quatro algorimtos de
busca diferentes: busca binária (\textit{sorted-array}), busca linear com boa
localidade (\textit{good-local-array}), busca linear com má localidade
(\textit{bad-local-array}) e busca linear com localidade péssima
(\textit{worse-local-array}).

Para árvores binárias, dois algoritmos foram usados: uma busca assumindo que a
árvore está ordenada (\textit{with-order-tree}), padrão de árvores de busca, e
uma busca que não assume isso (\textit{without-order-tree}). Sobre a lista
encadeada, foi usado apenas um algoritmo de busca linear (\textit{linked-list}).

Para cada estrutura de dados foram testadas duas operações: busca
(\textit{find}) e incremento de todos elementos menores que um certo valor
(\textit{inc-less-than}). A operação \textit{find} busca o elemento e retorna
um valor informando se o elemento foi encontrado, enquanto a operação
\textit{inc-less-than} de fato incrementa todos elementos menores que um dado
valor. Na figura \ref{fig:good local array find}, vemos a implementação da
operação \textit{find} para \textit{good-local-array}: é uma simples busca
linear e percorre pelos elementos em ordem, endereço após endereço.

A implementação da operação \textit{find} para \textit{bad-local-array} está na
figura \ref{fig:bad local array find}, que ao invés de percorrer em ordem, testa
o primeiro elemento da primeira página do \textit{array}, e então testa o
primeiro elemento da décima sexta página, então o primeiro elmento da trigésima
segunda página, até testar o primeiro elemento de cada grupo de dezesseis
páginas. Depois disso, ele testa o segundo elemento de cada grupo, e então
o terceiro, até que o último elemento de cada grupo seja testado. A expectativa
é que essa implementação pule páginas com muita frequência e force o TLB a
substituir páginas.

\begin{figure}
    \begin{code}{Rust}
pub fn find_good_local(&self, element: ElementType) -> bool {
    let mut i = 0;
    while i < self.elements.len() {
        if self.elements[i] == element {
            return true;
        }
        i += 1;
    }
    false
}
    \end{code}
    \caption{Implementação da operação \textit{find} para
        \textit{good-local-array}}
    \label{fig:good local array find}
\end{figure}

\begin{figure}
    \begin{code}{Rust}
pub fn find_bad_local(&self, element: ElementType) -> bool {
    let jump_pages = 16;
    let jump_elements = jump_pages * ELEMS_IN_PAGE;
    let mut offset = 0;
    while offset < jump_elements {
        let mut jump_page = 0;
        let mut index = jump_page * jump_pages + offset;
        while index < self.elements.len() {
            if self.elements[index] == element {
                return true;
            }
            jump_page += 1;
            index = jump_page * jump_pages + offset;
        }
        offset += 1;
    }
    false
}
    \end{code}
    \caption{Implementação da operação \textit{find} para
        \textit{bad-local-array}}
    \label{fig:bad local array find}
\end{figure}

\begin{figure}
    \begin{code}{Rust}
pub fn find_worse_local(&self, element: ElementType) -> bool {
    let rounded = self.elements.len() + ELEMS_IN_PAGE - 1;
    let pages = rounded / ELEMS_IN_PAGE;
    let half_size = pages / 2 * ELEMS_IN_PAGE;
    let jump_pages = 16;
    let jump_elements = jump_pages * ELEMS_IN_PAGE;
    let mut offset = 0;

    while offset < jump_elements {
        let mut jump_page = 0;
        let mut in_bounds = true;
        let mut index = jump_page * jump_pages + offset;
        while in_bounds {
            in_bounds = false;
            let lower_index = index;
            if lower_index < half_size {
                if self.elements[lower_index] == element {
                    return true;
                }
                in_bounds = true;
            }
            let upper_index = index + half_size;
            if upper_index < self.elements.len() {
                if self.elements[upper_index] == element {
                    return true;
                }
                in_bounds = true;
            }
            jump_page += 1;
            index = jump_page * jump_pages + offset;
        }
        offset += 1;
    }

    false
}
    \end{code}
    \caption{Implementação da operação \textit{find} para
        \textit{worse-local-array}}
    \label{fig:worse local array find}
\end{figure}

\nocite{*}
\printbibliography

\end{document}
